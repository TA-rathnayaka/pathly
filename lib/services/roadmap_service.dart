import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:pathly/models/roadmap.dart';
import 'package:pathly/models/roadmap_stage.dart';

class RoadmapService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  // Fetch all roadmaps from Firestore
  Future<List<Roadmap>> getRoadmaps() async {
    try {
      final snapshot = await _firestore.collection('roadmaps').get();
      return snapshot.docs.map((doc) {
        // Extract the list of stages, ensuring it's the correct type
        var stagesData = (doc['stages'] as List?)?.cast<Map<String, dynamic>>();

        return Roadmap(
          id: doc.id,
          title: doc['title'] ?? 'Untitled', // Fallback to a default if missing
          description: doc['description'] ?? '',
          icon: IconData(
            doc['icon'] is int ? doc['icon'] : int.tryParse(doc['icon'] ?? '0') ?? 0,
            fontFamily: 'MaterialIcons',
          ),
          stages: stagesData
              ?.map((stage) => RoadmapStage(
            title: stage['title'] ?? 'Untitled Stage',
            description: stage['description'] ?? '',
            dueDate: stage['dueDate'] is Timestamp
                ? (stage['dueDate'] as Timestamp).toDate()
                : (stage['dueDate'] is String
                ? DateTime.tryParse(stage['dueDate'])
                : null),
          ))
              .toList() ??
              [],
        );
      }).toList();
    } catch (e, stackTrace) {
      // Include stack trace for debugging purposes
      throw Exception('Failed to load roadmaps: $e\n$stackTrace');
    }
  }

  Future<Roadmap> getRoadmapById(String roadmapId) async {
    try {
      // Reference the specific roadmap document by ID
      final roadmapDocRef = _firestore.collection('roadmaps').doc(roadmapId);
      final roadmapDoc = await roadmapDocRef.get();

      // Check if the roadmap document exists
      if (roadmapDoc.exists) {
        // Extract the stages data
        var stagesData = (roadmapDoc['stages'] as List?)?.cast<Map<String, dynamic>>();

        // Return the mapped Roadmap object
        return Roadmap(
          id: roadmapDoc.id,
          title: roadmapDoc['title'] ?? 'Untitled',
          description: roadmapDoc['description'] ?? '',
          icon: IconData(
            roadmapDoc['icon'] is int ? roadmapDoc['icon'] : int.tryParse(roadmapDoc['icon'] ?? '0') ?? 0,
            fontFamily: 'MaterialIcons',
          ),
          stages: stagesData
              ?.map((stage) => RoadmapStage(
            title: stage['title'] ?? 'Untitled Stage',
            description: stage['description'] ?? '',
            dueDate: stage['dueDate'] is Timestamp
                ? (stage['dueDate'] as Timestamp).toDate()
                : (stage['dueDate'] is String
                ? DateTime.tryParse(stage['dueDate'])
                : null),
          ))
              .toList() ??
              [],
        );
      } else {
        throw Exception('Roadmap with ID $roadmapId not found');
      }
    } catch (e) {
      throw Exception('Failed to load roadmap by ID: $e');
    }
  }

  // Add a new roadmap to Firestore
  Future<String> addRoadmap(
      String title, String description, IconData icon) async {
    try {
      // Add the roadmap to Firestore and get the document reference
      final docRef = await _firestore.collection('roadmaps').add({
        'title': title,
        'description': description,
        'icon': icon.codePoint, // Store the icon code point
        'stages': [],
      });

      // Return the document ID (auto-generated by Firestore)
      return docRef.id;
    } catch (e) {
      throw Exception('Failed to add roadmap: $e');
    }
  }

  // Add a stage to a specific roadmap using the roadmapId
  Future<void> addStageToRoadmap(String roadmapId, RoadmapStage stage) async {
    try {
      // Reference the specific roadmap document by ID
      final roadmapDocRef = _firestore.collection('roadmaps').doc(roadmapId);
      final roadmapDoc = await roadmapDocRef.get();

      if (roadmapDoc.exists) {
        final stages = List<Map<String, dynamic>>.from(roadmapDoc['stages']);
        stages.add({
          'title': stage.title,
          'description': stage.description,
          'dueDate': stage.dueDate?.toIso8601String(),
        });

        // Update the roadmap document with the new stage
        await roadmapDocRef.update({'stages': stages});
      } else {
        throw Exception('Roadmap not found');
      }
    } catch (e) {
      throw Exception('Failed to add stage: $e');
    }
  }

  // Remove a stage from a specific roadmap using the roadmapId
  Future<void> removeStageFromRoadmap(String roadmapId, int stageIndex) async {
    try {
      // Reference the specific roadmap document by ID
      final roadmapDocRef = _firestore.collection('roadmaps').doc(roadmapId);
      final roadmapDoc = await roadmapDocRef.get();

      if (roadmapDoc.exists) {
        final stages = List<Map<String, dynamic>>.from(roadmapDoc['stages']);
        if (stageIndex < stages.length) {
          stages.removeAt(stageIndex);

          // Update the roadmap document with the removed stage
          await roadmapDocRef.update({'stages': stages});
        } else {
          throw Exception('Stage index out of bounds');
        }
      } else {
        throw Exception('Roadmap not found');
      }
    } catch (e) {
      throw Exception('Failed to remove stage: $e');
    }
  }

  // Update a stage in a specific roadmap using the roadmapId
  Future<void> updateStageInRoadmap(
      String roadmapId, int stageIndex, RoadmapStage updatedStage) async {
    try {
      // Reference the specific roadmap document by ID
      final roadmapDocRef = _firestore.collection('roadmaps').doc(roadmapId);
      final roadmapDoc = await roadmapDocRef.get();

      if (roadmapDoc.exists) {
        final stages = List<Map<String, dynamic>>.from(roadmapDoc['stages']);
        if (stageIndex < stages.length) {
          stages[stageIndex] = {
            'title': updatedStage.title,
            'description': updatedStage.description,
            'dueDate': updatedStage.dueDate?.toIso8601String(),
          };

          // Update the roadmap document with the updated stage
          await roadmapDocRef.update({'stages': stages});
        } else {
          throw Exception('Stage index out of bounds');
        }
      } else {
        throw Exception('Roadmap not found');
      }
    } catch (e) {
      throw Exception('Failed to update stage: $e');
    }
  }

  Future<List<String>> getEnrolledRoadmapIdsForUser(String userId) async {
    try {
      final snapshot = await _firestore
          .collection('users')
          .doc(userId)
          .collection('enrolledRoadmaps')
          .get();
      return snapshot.docs.map((doc) => doc.id).toList();
    } catch (e) {
      throw Exception('Failed to fetch enrolled roadmap IDs: $e');
    }
  }

  // Enroll a user in a roadmap
  Future<void> enrollUserInRoadmap(String userId, String roadmapId) async {
    try {
      await _firestore
          .collection('users')
          .doc(userId)
          .collection('enrolledRoadmaps')
          .doc(roadmapId)
          .set({});
    } catch (e) {
      throw Exception('Failed to enroll user in roadmap: $e');
    }
  }

  // Remove a user from a roadmap
  Future<void> removeUserFromRoadmap(String userId, String roadmapId) async {
    try {
      await _firestore
          .collection('users')
          .doc(userId)
          .collection('enrolledRoadmaps')
          .doc(roadmapId)
          .delete();
    } catch (e) {
      throw Exception('Failed to remove user from roadmap: $e');
    }
  }
}
